## 명령어란?
명령어는 특정 작업을 수행하기 위한 컴퓨터 프로그램의 명령입니다.

메모리에서 명령어를 가져와 해석하고 실행합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FboWo7G%2FbtsqTRP58Ti%2F58AX53rIu2pS0DFkYM49C0%2Fimg.png'>

명령어의 구조로는 **연산 코드(Operation Code)** 와 **오퍼랜드(operand)** 가 있습니다. 명렁어가 수행할 연산을 연산 코드라 하고, 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 오퍼랜드라고 합니다.

연산 코드는 연산자, 오퍼랜드는 피연산자 라고도 합니다.

그리고 주소 결정 방식이 있는데, 오퍼랜드의 주소를 알아내는데 사용합니다. 

### 오퍼랜드
오퍼랜드 필드에는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치가 주로 옵니다.

숫자와 문자 등을 나타내는 데이터, 메모리 주소, 레지스터 등이 그 예 입니다.

많은 경우 메모리 주소나 레지스터 이름이 담기기 때문에 주소 필드라고 부르기도 합니다.

오퍼랜드는 명령어 안에 하나도 없을 수 도 있고, 한 개 혹은 여러 개가 있을수 도 있습니다.

오퍼랜드가 하나도 없는 명령어는 0-주소 명령어, 하나면 1-주소 명령어, 두 개면 2-주소 명령어, 세 개면3-주소 명령어 라고 합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbWIedM%2FbtsqR94Nfgq%2FatfD2Nn9ewWkgbJjdB80gK%2Fimg.png'>

### 0-주소 명령어
- 연산코드부만 존재하고 주소를 지정하는 오퍼랜드가 존재하지 않는 명령어로, 모든 연산은 스택 포인터가 가리키는 오퍼랜드를 이용하여 명령을 수행합니다.

- 메모리에서 데이터를 가져오거나 메모리에 데이터를 저장하는 추가적인 메모리 접근 명령어가 필요하지 않기때문에 속도가 빠릅니다.

만약 'ADD' 라는 명령어가 있다면 이 명령어에는 오퍼랜드가 없기 때문에 스택의 최상단(TOS) 에서 두 값을 꺼내와서 (POP) 더한 후 다시 스택에 저장합니다. (PUSH)

0-주소 명령어는 주로 묵시적 주소지정 방식을 사용합니다.

### 1-주소 명령어
주소를 지정하는 오퍼랜드가 1개 있습니다.

누산기(AC) 를 이용하여 처리하며 수행 결과도 누산기에 저장합니다.

일반적으로 1-주소 명령어는 누산기나 다른 레지스터와 메모리 간의 연산을 수행하거나 데이터를 누산기나 레지스터로 로드하는 데 사용됩니다.

예시 코드로 'LOAD X' 라는 코드가 있습니다.

이 코드는 X번지 데이터를 누산기에 저장 (AC<-M[X]) 로 LOAD는 연산코드, X가 오퍼랜드 주소입니다.

### 2-주소 명령어
주소를 지정하는 오퍼랜드가 2개 있습니다.

가장 일반적인 명령어 방식입니다.

실행 속도가 빠르고 기억 장소 효율이 좋습니다.

단점으로는 연산 결과를 한 쪽 오퍼랜드에 저장할 때 한 쪽의 자료가 파괴됩니다. 

예시 코드로는 'ADD A,B' 가 있습니다. A 레지스터의 값과 B 레지스터의 값을 더한 후 값을 저장합니다. 만약 A 레지스터에 연산의 결과값을 저장한다면 A=A+B 로 A 레지스터의 원래의 값은 파괴됩니다.

### 3-주소 명령어
주소를 지정하는 오퍼랜드가 3개 있습니다.

2-주소 명령어와는 다르게 오퍼랜드 3에 연산 결과를 저장하기 때문에 연산 시 원래의 자료를 파괴하지 않습니다.

그러나 단점으로는 명령어 한 개의 길이가 너무 길어진다는 점이 있습니다. 

예시 코드로는 ADD A,B,C 가 있습니다 A+B->C 로 A+B의 결과값을 C 레지스터에 저장하는 코드입니다.

## OPCode
연산코드
연산 코드의 유형은 크게 네 가지로 나뉩니다.

 

1. 데이터 전송 :

MOVE : 데이터를 옮겨라

STORE : 메모리에 저장하라

LOAD : 메모리에서 CPU로 데이터를 가져와라

PUSH : 스택에 데이터를 저장하라

POP : 스택의 최상단 데이터를 가져와라

 

2. 산술/논리 연산 :

ADD, SUB, MUL, DIV : 사칙연산 (덧셈/뺄셈/곱셈/나눗셈)

AND, OR, NOT : 논리연산 

COMPARE : 두 값을 비교하라 

3. 제어 흐름 연산 :

JUMP : 특정 주소로 실행순서를 옮겨라

HALT : 프로그램의 실행을 멈춰라

CALL : 되돌아올 주소를 현재 위치로 저장하고 특정 주소로 실행 순서를 옮겨라

RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

4. 입출력 제어 :

READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라

WRITE(OUTPUT) : 특정 입출력 장치로부터 데이터를 써라

START IO : 입출력 장치를 시작하라

TEST IO : 입출력 장치의 상태를 확인하라

## 주소 지정 방식
1. 즉시 주소 지정방식 :

명령에 사용할 데이터를 오퍼랜드 필드 자체 내에 포함되어 있는 형태로 명령이 인출됨과 동시에 바로 명령어의 실행이 바로 이루어지는 방식입니다. 연산에 사용할 데이터를 메모리나 레지스터로부터 찾을 필요가 없기 때문에 가장 빠릅니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpV4qc%2FbtsqC9kSFi7%2FWqhUcPRT9gABKjAkccIskK%2Fimg.png'>

ADD A,42 라는 명령어가 있다. 이 명령어는 A 레지스터에 42를 더하는 명령을 수행합니다.

2. 직접 주소 지정방식 :

오퍼랜드 내의 주소를 실제 데이터의 주소로 직접 표현하는 방식입니다. 장점은 기억 장치상의 주소와 프로그램상의 주소가 일치하기 때문에 프로그램이 간결하게 작성되고, 뒤에 설명할 간접 주소 지정 방식에 비해 속도가 빠릅니다. 단점으로는 기억 장치의 용량이 큰 경우 오퍼랜드의 길이가 길어져 융통성이 부족하다는 점입니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmK0Rr%2FbtsqFtDvqh1%2F52hPjKQwtLNyZE7vaZH47K%2Fimg.png'>

ADD [200] [100] 이라는 명령어가 있습니다. 이 명령어는 각각 200, 100 의 메모리 주소의 값을 더하는 명령을 수행합니다.

3. 간접 주소 지정방식

유효 주소의 주소를 오퍼랜드 필드에 표현하는 방식입니다. 오퍼랜드의 주소부에 의해 기억 장치 내의 주소로 찾아간 후, 그 주소의 내용이 나타내는 주소에 실제 데이터가 기억됩니다. 실제 유효 주소를 구하기 위하여 한 번은 유효 주소를 가져오고, 한 번은 유효 주소로부터 실제 데이터를 가져오는 두 번의 메모리 참조가 수행됩니다.

장점은 오퍼랜드의 짧은 길이로 긴 주소를 접근할 수 있어 기억 장치의 용량이 큰 경우도 융통성이 보장됩니다. 단점은 기억 장치에 두 번 이상 접근해야 하기 때문에 데이터 처리 속도가 느립니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvFpSn%2FbtsqRfwOOrB%2FbiVYNMbJAGh0TBErTGOW1K%2Fimg.png'>

LOAD R1, 200

LOAD R2, 100

ADD [R1], [R2]

이 명령어는 레지스터 R1, R2에 200, 100이라는 메모리 주소값을 로드하고, ADD 명령어를 이용해서 메모리 주소 200, 100의 값을 더하는 명령을 수행합니다.

 

4. 레지스터 주소 지정방식

중앙 처리 장치 내의 레지스터에 실제 데이터가 기억되어 있는 방식입니다. 명령어의 주소부는 지정된 레지스터의 번호를 가집니다. 데이터 인출을 위해 주기억 장치에 접근할 필요가 없기 때문에 명령어 실행시간이 빨라집니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4v0pW%2FbtsqKyqDuiO%2FDgPcb5I6AOn1Zkk6cBJVYK%2Fimg.png'>

LOAD R1, 1000

LOAD R2, 2000

ADD R1, R2

이 명령어는 레지스터 R1, R2에 1000, 2000의 값을 로드하고 ADD 명령어로 두 레지스터의 값을 더하는 명령을 수행합니다.

 

5. 레지스터 간접 주소 지정방식

간접 주소 지정 방식과 레지스터 주소 방식을 혼합하여 만든 방식입니다. 오펴랜드가 레지스터를 저장하고, 그 레지스터의 값이 실제 데이터가 기억된 주소를 저장합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcb2fKu%2FbtsqQ9Q2RyO%2FOhkTfO8pkv6Ivih9BMLyp1%2Fimg.png'>

LOAD R1, 1000

LOAD R2, 2000

LOAD R3, [R1]

LOAD R4, [R2]

ADD R3, R4

이 명령어는 R1, R2 레지스터에 1000, 2000이라는 값을 넣어놓고 그 레지스터의 주소를 각각 R3, R4 에 넣어놓아서 간접 레지스터 주소 지정방식으로 쓴 코드입니다.

 

6. 묵시적 주소 지정방식, 스택 주소 지정방식

명령어를 실행하는데 필요한 데이터의 위치가 지정되어 있지 않고, 명령어의 정의에 의해 정해져 있는 방식입니다. 스택에서 스택포인터를 이용한 주소 지정 방식이라고 보면 됩니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsWMBW%2FbtsqPYvuOOs%2FxNr0r43k8S6K034sQ3TdAK%2Fimg.png'>

7. 변위 주소 지정방식 - 상대 주소 지정방식

변위 주소 지정방식은 오퍼랜드의 필드 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정방식으로 상대 주소 지정방식은 주로 상대적인 주소를 계산하여 접근할 때 사용되고, PC의 값과 오퍼랜드를 더해서 유효 주소를 얻는 방법입니다. PC에 들어 있는 명령어의 주소를 기준으로 오퍼랜드만큼 건너뛴 번지를 실행합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbb88GV%2FbtsqJThAEoy%2FNBizbOQzvFDIVmPqZiYDrK%2Fimg.png'>

8. 변위 주소 지정방식 - 베이스 레지스터 주소 지정방식

베이스 레지스터 주소 지정방식은 주로 배열이나 구조체와 같은 데이터 구조에 접근할 때 사용됩니다. 구조는 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 만드는 방식입니다. 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어냅니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCxjXL%2FbtsqR9Qyd9h%2FM0Wt4twqnrP1OMjaBCCCfk%2Fimg.png'>