## 명령어란?
명령어는 특정 작업을 수행하기 위한 컴퓨터 프로그램의 명령입니다.

메모리에서 명령어를 가져와 해석하고 실행합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FboWo7G%2FbtsqTRP58Ti%2F58AX53rIu2pS0DFkYM49C0%2Fimg.png'>

명령어의 구조로는 **연산 코드(Operation Code)** 와 **오퍼랜드(operand)** 가 있습니다. 명렁어가 수행할 연산을 연산 코드라 하고, 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 오퍼랜드라고 합니다.

연산 코드는 연산자, 오퍼랜드는 피연산자 라고도 합니다.

그리고 주소 결정 방식이 있는데, 오퍼랜드의 주소를 알아내는데 사용합니다. 

### 오퍼랜드
오퍼랜드 필드에는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치가 주로 옵니다.

숫자와 문자 등을 나타내는 데이터, 메모리 주소, 레지스터 등이 그 예 입니다.

많은 경우 메모리 주소나 레지스터 이름이 담기기 때문에 주소 필드라고 부르기도 합니다.

오퍼랜드는 명령어 안에 하나도 없을 수 도 있고, 한 개 혹은 여러 개가 있을수 도 있습니다.

오퍼랜드가 하나도 없는 명령어는 0-주소 명령어, 하나면 1-주소 명령어, 두 개면 2-주소 명령어, 세 개면3-주소 명령어 라고 합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbWIedM%2FbtsqR94Nfgq%2FatfD2Nn9ewWkgbJjdB80gK%2Fimg.png'>

### 0-주소 명령어
- 연산코드부만 존재하고 주소를 지정하는 오퍼랜드가 존재하지 않는 명령어로, 모든 연산은 스택 포인터가 가리키는 오퍼랜드를 이용하여 명령을 수행합니다.

- 메모리에서 데이터를 가져오거나 메모리에 데이터를 저장하는 추가적인 메모리 접근 명령어가 필요하지 않기때문에 속도가 빠릅니다.

만약 'ADD' 라는 명령어가 있다면 이 명령어에는 오퍼랜드가 없기 때문에 스택의 최상단(TOS) 에서 두 값을 꺼내와서 (POP) 더한 후 다시 스택에 저장합니다. (PUSH)

0-주소 명령어는 주로 묵시적 주소지정 방식을 사용합니다.

### 1-주소 명령어
주소를 지정하는 오퍼랜드가 1개 있습니다.

누산기(AC) 를 이용하여 처리하며 수행 결과도 누산기에 저장합니다.

일반적으로 1-주소 명령어는 누산기나 다른 레지스터와 메모리 간의 연산을 수행하거나 데이터를 누산기나 레지스터로 로드하는 데 사용됩니다.

예시 코드로 'LOAD X' 라는 코드가 있습니다.

이 코드는 X번지 데이터를 누산기에 저장 (AC<-M[X]) 로 LOAD는 연산코드, X가 오퍼랜드 주소입니다.

### 2-주소 명령어
주소를 지정하는 오퍼랜드가 2개 있습니다.

가장 일반적인 명령어 방식입니다.

실행 속도가 빠르고 기억 장소 효율이 좋습니다.

단점으로는 연산 결과를 한 쪽 오퍼랜드에 저장할 때 한 쪽의 자료가 파괴됩니다. 

예시 코드로는 'ADD A,B' 가 있습니다. A 레지스터의 값과 B 레지스터의 값을 더한 후 값을 저장합니다. 만약 A 레지스터에 연산의 결과값을 저장한다면 A=A+B 로 A 레지스터의 원래의 값은 파괴됩니다.

### 3-주소 명령어
주소를 지정하는 오퍼랜드가 3개 있습니다.

2-주소 명령어와는 다르게 오퍼랜드 3에 연산 결과를 저장하기 때문에 연산 시 원래의 자료를 파괴하지 않습니다.

그러나 단점으로는 명령어 한 개의 길이가 너무 길어진다는 점이 있습니다. 

예시 코드로는 ADD A,B,C 가 있습니다 A+B->C 로 A+B의 결과값을 C 레지스터에 저장하는 코드입니다.

## OPCode
연산코드
연산 코드의 유형은 크게 네 가지로 나뉩니다.

 

1. 데이터 전송 :

MOVE : 데이터를 옮겨라

STORE : 메모리에 저장하라

LOAD : 메모리에서 CPU로 데이터를 가져와라

PUSH : 스택에 데이터를 저장하라

POP : 스택의 최상단 데이터를 가져와라

 

2. 산술/논리 연산 :

ADD, SUB, MUL, DIV : 사칙연산 (덧셈/뺄셈/곱셈/나눗셈)

AND, OR, NOT : 논리연산 

COMPARE : 두 값을 비교하라 

3. 제어 흐름 연산 :

JUMP : 특정 주소로 실행순서를 옮겨라

HALT : 프로그램의 실행을 멈춰라

CALL : 되돌아올 주소를 현재 위치로 저장하고 특정 주소로 실행 순서를 옮겨라

RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

4. 입출력 제어 :

READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라

WRITE(OUTPUT) : 특정 입출력 장치로부터 데이터를 써라

START IO : 입출력 장치를 시작하라

TEST IO : 입출력 장치의 상태를 확인하라

## 주소 지정 방식
1. 즉시 주소 지정방식 :

명령에 사용할 데이터를 오퍼랜드 필드 자체 내에 포함되어 있는 형태로 명령이 인출됨과 동시에 바로 명령어의 실행이 바로 이루어지는 방식입니다. 연산에 사용할 데이터를 메모리나 레지스터로부터 찾을 필요가 없기 때문에 가장 빠릅니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpV4qc%2FbtsqC9kSFi7%2FWqhUcPRT9gABKjAkccIskK%2Fimg.png'>

ADD A,42 라는 명령어가 있다. 이 명령어는 A 레지스터에 42를 더하는 명령을 수행합니다.

2. 직접 주소 지정방식 :

오퍼랜드 내의 주소를 실제 데이터의 주소로 직접 표현하는 방식입니다. 장점은 기억 장치상의 주소와 프로그램상의 주소가 일치하기 때문에 프로그램이 간결하게 작성되고, 뒤에 설명할 간접 주소 지정 방식에 비해 속도가 빠릅니다. 단점으로는 기억 장치의 용량이 큰 경우 오퍼랜드의 길이가 길어져 융통성이 부족하다는 점입니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmK0Rr%2FbtsqFtDvqh1%2F52hPjKQwtLNyZE7vaZH47K%2Fimg.png'>

ADD [200] [100] 이라는 명령어가 있습니다. 이 명령어는 각각 200, 100 의 메모리 주소의 값을 더하는 명령을 수행합니다.

3. 간접 주소 지정방식

유효 주소의 주소를 오퍼랜드 필드에 표현하는 방식입니다. 오퍼랜드의 주소부에 의해 기억 장치 내의 주소로 찾아간 후, 그 주소의 내용이 나타내는 주소에 실제 데이터가 기억됩니다. 실제 유효 주소를 구하기 위하여 한 번은 유효 주소를 가져오고, 한 번은 유효 주소로부터 실제 데이터를 가져오는 두 번의 메모리 참조가 수행됩니다.

장점은 오퍼랜드의 짧은 길이로 긴 주소를 접근할 수 있어 기억 장치의 용량이 큰 경우도 융통성이 보장됩니다. 단점은 기억 장치에 두 번 이상 접근해야 하기 때문에 데이터 처리 속도가 느립니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvFpSn%2FbtsqRfwOOrB%2FbiVYNMbJAGh0TBErTGOW1K%2Fimg.png'>

LOAD R1, 200

LOAD R2, 100

ADD [R1], [R2]

이 명령어는 레지스터 R1, R2에 200, 100이라는 메모리 주소값을 로드하고, ADD 명령어를 이용해서 메모리 주소 200, 100의 값을 더하는 명령을 수행합니다.

 

4. 레지스터 주소 지정방식

중앙 처리 장치 내의 레지스터에 실제 데이터가 기억되어 있는 방식입니다. 명령어의 주소부는 지정된 레지스터의 번호를 가집니다. 데이터 인출을 위해 주기억 장치에 접근할 필요가 없기 때문에 명령어 실행시간이 빨라집니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4v0pW%2FbtsqKyqDuiO%2FDgPcb5I6AOn1Zkk6cBJVYK%2Fimg.png'>

LOAD R1, 1000

LOAD R2, 2000

ADD R1, R2

이 명령어는 레지스터 R1, R2에 1000, 2000의 값을 로드하고 ADD 명령어로 두 레지스터의 값을 더하는 명령을 수행합니다.

 

5. 레지스터 간접 주소 지정방식

간접 주소 지정 방식과 레지스터 주소 방식을 혼합하여 만든 방식입니다. 오펴랜드가 레지스터를 저장하고, 그 레지스터의 값이 실제 데이터가 기억된 주소를 저장합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcb2fKu%2FbtsqQ9Q2RyO%2FOhkTfO8pkv6Ivih9BMLyp1%2Fimg.png'>

LOAD R1, 1000

LOAD R2, 2000

LOAD R3, [R1]

LOAD R4, [R2]

ADD R3, R4

이 명령어는 R1, R2 레지스터에 1000, 2000이라는 값을 넣어놓고 그 레지스터의 주소를 각각 R3, R4 에 넣어놓아서 간접 레지스터 주소 지정방식으로 쓴 코드입니다.

 

6. 묵시적 주소 지정방식, 스택 주소 지정방식

명령어를 실행하는데 필요한 데이터의 위치가 지정되어 있지 않고, 명령어의 정의에 의해 정해져 있는 방식입니다. 스택에서 스택포인터를 이용한 주소 지정 방식이라고 보면 됩니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsWMBW%2FbtsqPYvuOOs%2FxNr0r43k8S6K034sQ3TdAK%2Fimg.png'>

7. 변위 주소 지정방식 - 상대 주소 지정방식

변위 주소 지정방식은 오퍼랜드의 필드 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정방식으로 상대 주소 지정방식은 주로 상대적인 주소를 계산하여 접근할 때 사용되고, PC의 값과 오퍼랜드를 더해서 유효 주소를 얻는 방법입니다. PC에 들어 있는 명령어의 주소를 기준으로 오퍼랜드만큼 건너뛴 번지를 실행합니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbb88GV%2FbtsqJThAEoy%2FNBizbOQzvFDIVmPqZiYDrK%2Fimg.png'>

8. 변위 주소 지정방식 - 베이스 레지스터 주소 지정방식

베이스 레지스터 주소 지정방식은 주로 배열이나 구조체와 같은 데이터 구조에 접근할 때 사용됩니다. 구조는 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 만드는 방식입니다. 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어냅니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCxjXL%2FbtsqR9Qyd9h%2FM0Wt4twqnrP1OMjaBCCCfk%2Fimg.png'>

## 명령어 수행 과정
명령어의 수행 과정은 다섯 단계로 나뉩니다.

1. **명령어 인출(Instruction Fetch)** : 명령어 주소를 계산하고 그 주소에 가서 명령어를 가져오는 단계를 수행합니다. 
2. **명령어 해독(Instruction Decode)** : 읽어온 명령어를 해독하여 수행해야 할 동작을 결정합니다.

***명령어 인출/ 해독은 모든 명령어들에 대하여 공통적으로 수행합니다.***

3. 데이터 인출(Data Fetch) : 명령어 실행 시 데이터가 필요한 경우에, 기억장치 혹은 입출력 장치로부터 그 데이터를 읽어옵니다.
4. 데이터 처리(Data Process) : 데이터에 대한 산술 및 논리적 연산을 수행합니다.
5. 데이터 저장 (Data Store) : 수행한 결과를 저장합니다.

***데이터 인출/처리/저장은 명령어에 따라서 필요한 경우에만 수행합니다.***

이와 같은 5개의 과정을 **명령어 사이클(Instruction Cycle)** 이라고 합니다.

명령어 사이클은 CPU가 한 개의 명령어를 수행할 때 필요한 처리 과정으로서, CPU는 이 과정을 프로그램 실행을 시작한 순간부터 중단될 때 까지 무한히 반복합니다.

명렁어 사이클은 두 개의 부사이클(subcycle) 로 나뉘는데, 인출 사이클과 실행 사이클이 있습니다.

* 인출 사이클(Fetch Cycle) : CPU가 기억 장치로부터 명령어를 읽어오는 단계입니다. (=명령어 인출)
* 실행 사이클(Execution Cycle) : 명령어를 실행하는 단계입니다. (=명령어 해독 ~ 데이터 저장)

이 두 사이클에 대해서 더 자세히 알아보기 위해 CPU의 내부 구조에 대해서 알아보도록 하겠습니다!

## CPU의 내부구조
<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDIpsU%2FbtsrCvzsUWy%2FAFowaOiay7etl1bkzYbn3k%2Fimg.png'>

1. **산술 논리장치 (Arithmetic Logic Unit, ALU)** : 두 수의 산술연산(덧셈, 뺄셈 등)과 논리연산 (논리합, 논리곱 등)을 계산하는 디지털 회로입니다. 
2. **레지스터 세트 (register set)** : CPU 내부에 위치한 기억장치입니다. 엑세스 속도가 빠르지만, 내부 회로가 복잡하여 많은 공간을 차지하기 때문에, CPU 내부의 레지스터 개수는 제한적입니다. 용도에 따라 범용 레지스터와 특수 목적 레지스터로 구분됩니다. 
3. **제어 장치 (Control Unit)** : 컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치입니다. 제어 장치는 읽어들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시합니다.
4. **버스 시스템 (Bus system)** : CPU 내부의 구성요소들 간에 데이터, 주소 및 제어 신호를 전달하는 통로입니다. 데이터 버스, 주소 버스, 제어 버스 등 다양한 유형의 버스로 구성됩니다.
5. **CPU 내부 버스** : ALU와 레지스터들 사이의 데이터 이동을 위한 데이터, 주소 선들 입니다. 제어 장치로부터 발생되는 제어 신호를 전송하는 선들로 구성되어 있습니다.

CPU 내부에 특수 목적 레지스터 세트에는 어떤 레지스터가 있는지 알아보겠습니다.

1. **PC (Program Counter, 프로그램 카운터)** : 다음에 인출될 명령어의 주소를 가지고 있는 레지스터 입니다. 만약 현재 100주소의 명령어를 실행 중일 경우, PC 값은 101입니다.
2. **MAR (Memory Address Register, 메모리 주소 레지스터)** : PC에 저장된 명령어 주소가 주소 버스를 통해 출력되기 전에 일시적으로 저장되는 주소 레지스터 입니다.
3. **MBR (Memory Buffer Register, 메모리 버퍼 레지스터)** : 기억장치에 저장될, 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터 입니다.
4. **IR (Instruction Register, 명령어 레지스터)** : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터 입니다.
5. **AC (Accumulator, 누산기)** : 연산 결과 데이터를 일시적으로 저장하는 레지스터 입니다.

### 인출 사이클 (Fetch Cycle)
이제 인출 사이클에 대해 알아보도록 하겠습니다.

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fk3Z0W%2FbtsrH6rTA2W%2F4YGGXIuvgYc1WqHYahIGNK%2Fimg.png'>

위 사진이 Fetch Cycle의 처리 과정 입니다. 사진처럼 CPU의 주기가 1씩 증가할 때마다 t0, t1, t2입니다.

1. **t0 : MAR ← PC** : PC가 가리키는 다음에 실행할 명령어의 주소를 CPU 내부 버스를 통하여 MAR에 저장해줍니다. PC의 값이 외부의 주소 버스로 가기 위해서는 MAR을 거쳐야 합니다.
2. **t1 : MBR ← M[MAR], PC ← PC + 1** : 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통하여 MBR에 저장시킵니다. 그리고 PC의 값을 1 증가시킵니다.
3. **t2 : IR ← MBR** : MBR에 있는 명령어 코드가 해석되기 위하여 IR로 이동됩니다.

여기까지가 인출 사이클의 단계입니다.

### 실행 사이클 (Execute Cycle)
다음으로 실행 사이클에 대해서 알아보도록 하겠습니다. 

실행 사이클동안에는 CPU가 명령어 코드를 해독하고, 그 결과에 따라 필요한 연산을 수행합니다.
연산의 종류로는 데이터 이동, 데이터 처리, 데이터의 저장, 프로그램 제어가 있습니다.
아래 설명된 연산 종류는 필수로 수행하는 과정이 아닌, 명령어에 따라 달라집니다.

1. **데이터의 이동 (LOAD [addr] 명령어)**

기억장치에 저장되어있는 데이터를 CPU 내부의 레지스터인 AC로 이동하는 명령어입니다.

**t0 : MAR ← IR (addr)** : IR에 있는 명령어의 주소 부분을 MAR로 전송합니다.

**t1 : MBR ← M[MAR]** : 그 주소가 지정한 메모리로부터 데이터를 인출하여 MBR로 전송합니다.

**t2 : AC ← MBR** : 그 데이터를 AC에 적재합니다.

 

2. **데이터의 저장(STA [addr] 명령어)**

**t0 : MAR ← IR (addr)** : 현재 실행 중인 명령어에서 가져온 데이터를 저장할 기억장치의 주소(addr)를 MAR로 전송합니다.

**t1 : MBR ← AC** : 누산기의 데이터를 MBR로 전송합니다.

**t2 : M[MAR] ← MBR** : MBR의 데이터를 MAR이 지정하는 메모리에 저장합니다.

 

3. **데이터의 처리(ADD [addr] 명령어)**

데이터의 처리 명령어중 ADD 명령어를 사용한다고 가정합시다. 이 명령어는 기억장치에 저장된 데이터를 누산기의 데이터와 더하고 그 결과를 다시 누산기에 저장하는 명령어입니다.

**t0 : MAR ← IR (addr)** : IR 에서 가져온 주소를 MAR에 전송합니다.

**t1 : MBR ← M[MAR]** : 그 주소에 해당하는 메모리의 데이터를  MBR로 전송합니다.

**t2 : AC ← AC + MBR** : 그 데이터와 누산기의 데이터를 더하고 결과값을 다시 누산기에 저장합니다.

이때 AC에 저장된 값과 MBR의 값을 ALU에 전송합니다. 그리고 ALU에서 연산이 진행되고, 그 결과값이 AC에 저장되는 순서입니다.

<img src ='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFkB2l%2FbtsrDILRC15%2FEQxalhUK7FVT7eRG3ZkWB0%2Fimg.png'>

4. **프로그램 제어 (JUMP [addr] 명령어)**

오퍼랜드(addr)가 가리키는 위치의 명령어로 실행 순서를 변경하는 명령어 입니다.

**t0 : PC ← IR (addr)** : 명령어의 오퍼랜드를 Program Counter에 저장합니다. 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로, 분기(조건에 따라 프로그램의 실행 흐름을 변경하는 동작)가 발생합니다.