## 람다식
람다식(Lambda Expression) 이란 **함수를 하나의 식(expression)으로 표현한 것** 이다. 함수를 람다식으로 표현하면 이름이 필요없기 때문에 **익명 함수(Anonymous Function)** 의 한 종류로 볼 수 있다.

익명함수란 함수의 이름이 없는 함수로, 익명함수들은 모두 일급 객체이다. 일급 객체인 함수는 변수처럼 사용 가능하며 매개 변수로 전달이 가능하다는 특징을 가지고 있다.

아래는 기존의 함수 선언문이다.
```java
반환 타입 메소드명 (매개변수, ...){
    실행문
}

//예시
public String hello(){
    return "Hello World!";
}
```

람다 방식으로는 위 코드 처럼 메소드 명이 불필요하며, 괄호() 와 화살표 -> 를 이용하여 함수를 선언한다.
```java
(매개변수, ...) -> 실행문 {실행문 ...}

//예시
() -> "hello world!";
```

람다식이 등장하게 된 이유는 불필요한 코드를 줄이고, 가독성을 높이기 위함이다. 그렇기 때문에 함수형 인터페이스의 인스턴스를 생성하여 함수를 변수처럼 선언하는 람다식 에서는 메소드의 이름이 불필요하다고 여겨져서 사용하지 않는다. 대신 컴파일러가 타입을 추론한다. 또한 람다식으로 선언된 함수는 1급 객체 이므로 Stream API의 매개변수로 전달이 가능하다.

### 람다식의 특징
* 람다식 내에서 사용되는 지역변수는 `final` 이 붙지 않아도 상수로 간주된다.
* 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

### 람다식의 장점
1. 코드를 간결하게 할 수 있다.
2. 식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
3. 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
4. 병렬프로그래밍에 용이하다.

### 람다식의 단점
1. 람다를 사용하며 만든 무명함수는 재사용이 불가능하다.
2. 디버깅이 어렵다.
3. 람다를 많이 사용하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
4. 재귀로 만들 경우 부적합하다.

## 함수형 인터페이스 (Functional Interface)
람다식으로 순수 함수를 선언할 수 있지만 Java는 순수 함수와 일반 함수를 다르게 취급하며, Java에서는 이를 구분하기 위해 함수형 인터페이스가 등장하게 되었다.

함수형 인터페이스란 **함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션** 으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할을 한다. 이를 사용하는 이유는 Java의 람다식이 함수형 인터페이스만을 반환하기 때문이다.

예시로 두값중 큰 값을 구하는 익명함수를 개발하였다면 지금까지는 아래와 같이 하였을것이다.

```java
public class Lambda{

    public static void main(String[] args){

        // 기존의 익명함수
        System.out.println(new MyLambdaFunction(){
            public int max(int a, int b){
                return a>b?a:b;
            }
        }.max(3,5));
    }
}
```

하지만 함수형 인터페이스의 등장으로 **함수를 변수처럼 선언**할 수 있게 되었고, 코드또한 간결해졌다. 함수형 인터페이스를 구현하기 위해서는 인터페이스를 개발하여 그 내부에는 1개뿐인 `abstract` 함수를 선언하고, `@FunctionalInterface` 어노테이션을 붙여주면 된다. 아래는 위 코드를 람다식으로 변경한 코드이다.

```java
@FuntionalInterface
interface MyLambdaFunction{
    int max(int a, int b);
}

public class Lambda{

    public static void main(String[] args){

        //람다식을 이용한 익명함수
        MyLambdaFunction lambdaFunction = (int a, int b)-> a > b ? a : b;
        System.out.println(lambdaFunction.max(3,5));
    }
}
```

`@FunctionalInterface` 는 해당 인터페이스가 1개의 함수만을 갖도록 제한하기 때문에, 여러 개의 함수를 선언하면 컴파일 에러가 발생할 수 있다.